# Process Creation and Shellcode Execution
## Description

This POC demonstrates how to create a new process (in this case, launching an instance of Notepad) and then inject and execute shellcode within that process. Essentially, the code shows a technique often used in malware or penetration testing—code injection—where executable code (shellcode) is written into the memory space of another process and then executed. The POC uses Python’s ctypes library to interface directly with Windows API functions.

## What the POC does
1. Process Creation:
  The code begins by creating a new process (Notepad.exe) using the Windows API call CreateProcessA. In many cases, the process is started in a suspended state (using flags such as CREATE_SUSPENDED), which gives the POC time to inject the shellcode before the process begins normal execution.

2. Memory Allocation in Remote Process:
  Using VirtualAllocEx, the POC allocates a block of memory in the target process (Notepad). This allocated memory will later hold the shellcode. The allocation is done with the combined flags MEM_COMMIT | MEM_RESERVE and initially set to PAGE_READWRITE.

3. Shellcode Injection:
  The shellcode, which is generated via tools like msfvenom, is stored as a byte string in the code. The function WriteProcessMemory writes this shellcode into the allocated memory within the remote process.

4. Changing Memory Protection:
  To allow the shellcode to be executed, the memory protection is changed from PAGE_READWRITE to PAGE_EXECUTE_READ using VirtualProtectEx. This is a critical step because Windows requires memory pages to have execute permissions if they are to be run as code.

5. Executing the Shellcode:
  Instead of directly creating a new thread to execute the shellcode (which is an option using CreateRemoteThread—although it’s commented out here), the POC uses QueueUserAPC (Asynchronous Procedure Call). An APC is queued to the suspended thread, pointing to the shellcode’s address. Finally, ResumeThread is called on the target process’s main thread, which then processes the queued APC and executes the shellcode.

6. Two Variants of Shellcode:
   1. Generic Shellcode: The first part of the code uses shellcode generated by msfvenom.
   2. Reverse Shell Payload: Later, the POC demonstrates a variant intended to provide a reverse shell. The reverse shell payload is also generated via msfvenom (with parameters like LHOST and LPORT to define the attacker’s IP and port).

## Detailed Code Walkthrough
1. Importing and Setting Up Windows API Functions
   1.Libraries and ctypes:
The script imports modules from Python’s ctypes and wintypes to interact with low-level Windows APIs. This allows the POC to call functions like VirtualAllocEx, WriteProcessMemory, and others directly.

  2. Defining Function Prototypes:
Each API function (e.g., VirtualAllocEx, WriteProcessMemory, VirtualProtectEx) is given the correct argument types (argtypes) and return types (restype). This is essential for ensuring that the calls are made correctly to the underlying Windows DLLs.

  3. Structures:
Custom structures such as _SECURITY_ATTRIBUTES, STARTUPINFO, and PROCESS_INFORMATION are defined. These mirror the corresponding Windows structures needed for functions like CreateProcessA. They hold process handles, thread handles, process IDs, and configuration details required during process creation.

2. Process Creation
Launching Notepad:
The POC uses CreateProcessA to start an instance of Notepad. The code comments indicate that the process is created in a suspended state (using flags like CREATE_SUSPENDED), which is crucial as it prevents the process from running immediately. This allows time for shellcode injection before the process resumes normal execution.

Obtaining Process Information:
After process creation, the code extracts important details like the process handle, process ID, thread handle, and thread ID from the PROCESS_INFORMATION structure.

3. Memory Allocation and Shellcode Injection
Memory Allocation:
With the process handle, VirtualAllocEx is called to allocate a block of memory within the remote process’s address space. This memory is reserved for the shellcode payload.

Writing Shellcode:
The shellcode (a sequence of bytes) is written into the allocated memory using WriteProcessMemory. This function copies the shellcode from the current process (our POC) into the target process’s memory.

Memory Protection Change:
To make sure the shellcode can be executed, VirtualProtectEx is used to change the memory protection settings on the allocated block from writable to executable. This transition is a common step in code injection techniques.

4. Triggering Shellcode Execution
APC Queueing:
The POC uses QueueUserAPC to schedule the execution of the shellcode in the context of the target process’s thread. By queuing an APC that points to the address where the shellcode is stored, the injected code is set to run when the thread enters an alertable state.

Resuming the Process Thread:
Finally, ResumeThread is called on the previously suspended thread. Once resumed, the thread processes the queued APC, and the shellcode is executed.


## Prerequisites
1. Install Python from the official website: [python.org](https://www.python.org/downloads/).
2. Create a virtual environment to manage dependencies:
   ```bash
   python -m venv myenv
